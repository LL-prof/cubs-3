<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cube Builder</title>
  <style>
    html, body { height: 100%; margin: 0; }
    canvas { display: block; }

    #ui{
      position:fixed; top:12px; left:12px;
      background:rgba(255,255,255,.92);
      padding:12px 12px; border-radius:14px;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size:14px; line-height:1.35;
      box-shadow:0 6px 18px rgba(0,0,0,.15);
      max-width:380px; user-select:none;
    }
    .hint{ opacity:.85; font-size:12px; margin-top:6px; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px; }

    .mode-btn{
      padding:10px 14px;
      border-radius:14px;
      border:2px solid #ddd;
      background:#fff;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.2px;
      min-width:110px;
    }
    .mode-btn.active{
      border-color:#111;
      box-shadow:0 2px 10px rgba(0,0,0,.12);
    }

    button, input[type="color"]{
      padding:8px 12px; border-radius:12px;
      border:1px solid #ddd; background:#fff; cursor:pointer;
      font-weight:600;
    }
    button:hover{ background:#f6f6f6; }
    input[type="color"]{ height:42px; width:54px; padding:0; border-radius:12px; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="ui">
    <div><b>Constructor de cubs</b></div>

    <div class="row">
      <button id="btnPlace" class="mode-btn active">ðŸŸ¦ AFEGIR</button>
      <button id="btnErase" class="mode-btn">ðŸ§½ BORRAR</button>
    </div>

    <div id="modeHint" class="hint">ARA: <b>AFEGIR</b></div>

    <div class="row">
      <label style="font-weight:700;">Color</label>
      <input id="color" type="color" value="#4da3ff" />
      <button id="clear">Borrar todo</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // --- Escena ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf3f5f7);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(10, 12, 14);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Controles
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.screenSpacePanning = true;
    controls.target.set(0, 0, 0);
    controls.update();

    // Luces
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // Grid + suelo invisible (raycast)
    const GRID_SIZE = 20;
    scene.add(new THREE.GridHelper(GRID_SIZE, GRID_SIZE, 0x9aa4ad, 0xd0d6dc));

    const groundGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE);
    groundGeo.rotateX(-Math.PI / 2);
    const ground = new THREE.Mesh(
      groundGeo,
      new THREE.MeshStandardMaterial({ transparent: true, opacity: 0.0 })
    );
    ground.name = "GROUND";
    scene.add(ground);

    // Cubos
    const cubeGeo = new THREE.BoxGeometry(1,1,1);
    const cubes = new Map(); // key -> mesh
    const keyOf = (x,y,z) => `${x},${y},${z}`;

    function hasCube(x,y,z){
      return cubes.has(keyOf(x,y,z));
    }
    function faceExposed(x,y,z, dx,dy,dz){
      return !hasCube(x+dx, y+dy, z+dz);
    }

    // --- OUTLINE GLOBAL (solo contorno exterior real) ---
    let outline = null;
    let outlineGeo = null;
    let outlineMat = null;

    function edgeKey(ax,ay,az, bx,by,bz){
      const A = `${ax},${ay},${az}`;
      const B = `${bx},${by},${bz}`;
      return (A < B) ? `${A}|${B}` : `${B}|${A}`;
    }

    function addEdge(edgeMap, ax,ay,az, bx,by,bz, normalId){
      const k = edgeKey(ax,ay,az, bx,by,bz);
      let entry = edgeMap.get(k);
      if (!entry){
        entry = { count: 0, normals: new Set() };
        edgeMap.set(k, entry);
      }
      entry.count += 1;
      entry.normals.add(normalId);
    }

    function rebuildOutline(){
      const edgeMap = new Map();

      for (const m of cubes.values()){
        const {x,y,z} = m.userData;

        const x0=x,   x1=x+1;
        const y0=y,   y1=y+1;
        const z0=z,   z1=z+1;

        // +X
        if (faceExposed(x,y,z, +1,0,0)){
          const n = "+X";
          addEdge(edgeMap, x1,y0,z0, x1,y1,z0, n);
          addEdge(edgeMap, x1,y0,z1, x1,y1,z1, n);
          addEdge(edgeMap, x1,y0,z0, x1,y0,z1, n);
          addEdge(edgeMap, x1,y1,z0, x1,y1,z1, n);
        }
        // -X
        if (faceExposed(x,y,z, -1,0,0)){
          const n = "-X";
          addEdge(edgeMap, x0,y0,z0, x0,y1,z0, n);
          addEdge(edgeMap, x0,y0,z1, x0,y1,z1, n);
          addEdge(edgeMap, x0,y0,z0, x0,y0,z1, n);
          addEdge(edgeMap, x0,y1,z0, x0,y1,z1, n);
        }
        // +Y (top)
        if (faceExposed(x,y,z, 0,+1,0)){
          const n = "+Y";
          addEdge(edgeMap, x0,y1,z0, x1,y1,z0, n);
          addEdge(edgeMap, x0,y1,z1, x1,y1,z1, n);
          addEdge(edgeMap, x0,y1,z0, x0,y1,z1, n);
          addEdge(edgeMap, x1,y1,z0, x1,y1,z1, n);
        }
        // -Y (bottom)
        if (faceExposed(x,y,z, 0,-1,0)){
          const n = "-Y";
          addEdge(edgeMap, x0,y0,z0, x1,y0,z0, n);
          addEdge(edgeMap, x0,y0,z1, x1,y0,z1, n);
          addEdge(edgeMap, x0,y0,z0, x0,y0,z1, n);
          addEdge(edgeMap, x1,y0,z0, x1,y0,z1, n);
        }
        // +Z
        if (faceExposed(x,y,z, 0,0,+1)){
          const n = "+Z";
          addEdge(edgeMap, x0,y0,z1, x1,y0,z1, n);
          addEdge(edgeMap, x0,y1,z1, x1,y1,z1, n);
          addEdge(edgeMap, x0,y0,z1, x0,y1,z1, n);
          addEdge(edgeMap, x1,y0,z1, x1,y1,z1, n);
        }
        // -Z
        if (faceExposed(x,y,z, 0,0,-1)){
          const n = "-Z";
          addEdge(edgeMap, x0,y0,z0, x1,y0,z0, n);
          addEdge(edgeMap, x0,y1,z0, x1,y1,z0, n);
          addEdge(edgeMap, x0,y0,z0, x0,y1,z0, n);
          addEdge(edgeMap, x1,y0,z0, x1,y1,z0, n);
        }
      }

      // Nos quedamos solo con:
      // - aristas que aparecen una vez (borde libre)
      // - o aristas con normales distintas (esquina real)
      const kept = [];
      for (const [k, entry] of edgeMap.entries()){
        if (entry.count === 1 || entry.normals.size > 1){
          kept.push(k);
        }
      }

      const positions = new Float32Array(kept.length * 2 * 3);
      let i = 0;
      for (const k of kept){
        const [a,b] = k.split("|");
        const [ax,ay,az] = a.split(",").map(Number);
        const [bx,by,bz] = b.split(",").map(Number);

        positions[i++] = ax; positions[i++] = ay; positions[i++] = az;
        positions[i++] = bx; positions[i++] = by; positions[i++] = bz;
      }

      if (outline){
        scene.remove(outline);
        if (outlineGeo) outlineGeo.dispose();
      }

      outlineGeo = new THREE.BufferGeometry();
      outlineGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      if (!outlineMat){
        outlineMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.85 });
      }

      outline = new THREE.LineSegments(outlineGeo, outlineMat);
      outline.renderOrder = 10;
      scene.add(outline);
    }

    function addCube(x, y, z, colorHex){
      const k = keyOf(x,y,z);
      if (cubes.has(k)) return;

      const mat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.7 });
      const m = new THREE.Mesh(cubeGeo, mat);
      m.position.set(x+0.5, y+0.5, z+0.5);
      m.userData = { x,y,z, colorHex };

      scene.add(m);
      cubes.set(k, m);

      rebuildOutline();
    }

    function removeCube(x,y,z){
      const k = keyOf(x,y,z);
      const m = cubes.get(k);
      if (!m) return;

      scene.remove(m);
      m.material.dispose(); // NO dispose geometry (compartida)
      cubes.delete(k);

      rebuildOutline();
    }

    function clearAll(){
      for (const m of cubes.values()){
        scene.remove(m);
        m.material.dispose();
      }
      cubes.clear();
      rebuildOutline();
    }
    document.getElementById("clear").addEventListener("click", clearAll);

    // --- Modo PONER / BORRAR ---
    let mode = "place";
    const btnPlace = document.getElementById("btnPlace");
    const btnErase = document.getElementById("btnErase");
    const modeHint = document.getElementById("modeHint");

    function setMode(next){
      mode = next;
      btnPlace.classList.toggle("active", mode === "place");
      btnErase.classList.toggle("active", mode === "erase");
      modeHint.innerHTML = mode === "place"
        ? 'ARA: <b>AFEGIR</b>'
        : 'ARA: <b>BORRAR</b>';
    }
    btnPlace.addEventListener("click", () => setMode("place"));
    btnErase.addEventListener("click", () => setMode("erase"));

    // Raycaster
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function withinGrid(x,z){
      const half = GRID_SIZE/2;
      return (x >= -half && x < half && z >= -half && z < half);
    }

    // --- Evitar cubo fantasma al mover cÃ¡mara ---
    let downX = 0, downY = 0;
    let moved = false;
    let activeButton = -1;
    const MOVE_TOLERANCE = 6;

    renderer.domElement.addEventListener("pointerdown", (ev) => {
      if (ev.target && ev.target.closest && ev.target.closest("#ui")) return;
      activeButton = ev.button;
      downX = ev.clientX;
      downY = ev.clientY;
      moved = false;
    });

    renderer.domElement.addEventListener("pointermove", (ev) => {
      if (activeButton === -1) return;
      const dx = Math.abs(ev.clientX - downX);
      const dy = Math.abs(ev.clientY - downY);
      if (dx > MOVE_TOLERANCE || dy > MOVE_TOLERANCE) moved = true;
    });

    renderer.domElement.addEventListener("pointerup", (ev) => {
      if (activeButton !== 0) { activeButton = -1; return; }
      if (moved) { activeButton = -1; return; }

      mouse.x = (ev.clientX / innerWidth) * 2 - 1;
      mouse.y = -(ev.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const hits = raycaster.intersectObjects([ground, ...cubes.values()], false);
      if (!hits.length) { activeButton = -1; return; }

      const hit = hits[0];

      // BORRAR
      if (mode === "erase") {
        if (hit.object !== ground) {
          const { x, y, z } = hit.object.userData;
          removeCube(x, y, z);
        }
        activeButton = -1;
        return;
      }

      // PONER
      const colorHex = parseInt(document.getElementById("color").value.replace("#","0x"));

      if (hit.object === ground) {
        const p = hit.point;
        const x = Math.floor(p.x);
        const z = Math.floor(p.z);
        if (!withinGrid(x, z)) { activeButton = -1; return; }
        addCube(x, 0, z, colorHex);
        activeButton = -1;
        return;
      }

      const obj = hit.object;
      const { x, y, z } = obj.userData;

      const n = hit.face.normal.clone().applyQuaternion(obj.quaternion);
      const step = new THREE.Vector3(Math.round(n.x), Math.round(n.y), Math.round(n.z));

      const nx = x + step.x;
      const ny = y + step.y;
      const nz = z + step.z;

      if (ny < 0 || ny > 40) { activeButton = -1; return; }
      if (!withinGrid(nx, nz)) { activeButton = -1; return; }

      addCube(nx, ny, nz, colorHex);
      activeButton = -1;
    });

    window.addEventListener("pointerup", () => { activeButton = -1; });

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Cubo inicial
    addCube(0,0,0, 0x4da3ff);
  </script>
</body>
</html>
